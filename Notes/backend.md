# Making Service Requests with HTTP or CURL
The browser inplicitly asks for `index.html`. Then it gets the file from the server. The server returns those static files. What if the JS running in the front end could make their own requests? So they introduced the XML API. It can go and return the weather or just about anything you want. If we want to request something else, we communicate with HTTP requests.

We make service requests with `curl` looks like:
```
curl -v -s http://info.cern.ch/hypertext/WWW/Helping.html
```

We can change our server to call up service endpoints. These are just functions/methods. Sometimes they are called API's. My service can also call other services like a database or other API. When we hard reload a page, it makes a bunch of service requests (HTML requests for different resources).`xhr` are service requests.

How do we get a resource: `https://byu.edu:443/api/city?q=pro#3`
- `https://` is the scheme or what language we are speaking in
- `byu.edu` is the domain name or who we want to talk to
- `:443` is the port or what software we want to talk to, kind of like the address.
- `/api/city` is the path
- `?q=pro` is the parameter (separated with `&`)
- `#3` is the anchor (one of the sections (often an id on an html tag))

Our server has two programs that are running. One is simon, the other is startup. Both are running on different ports.

It would be confusing if you sayd go to port 3000 on my server. So instead by default go to port 443 (port 80 is the insecure one) with a specific domain name (like `simon.` or `startup.`). So we have Caddy listening on 443. Caddy has a table for the `simon.` or `startup.`. It will then forward it to one program or the other and then return it at the end. Caddy is called a proxy. The programs it runs are differentiated by the subdomain name.

There is another program called SSHD which is how we run the deployment scripts. It is on port 22.

When we go to a website while our port is running, it will connect over port 443, but then slide us over to another port.

## HTTP Requests
Server doesn't make requests to the client. The client makes requests to the server. Here is an example request.
```
POST /user HTTP/1.1
Host: cs260.click
User-Agent: curl/7.77.0
Content-Length: 14
Accept: application/json, text/plain, */*
accept-encoding: gzip, deflate

{"name":"tim"}
```

The basic syntax looks like this:
```
<verb> <url path, parameters, anchor> <version>
[<header key: value>]*
[

  <body>
]
```

- `POST` is the method
- `/user` is the path
- `HTTP/1.1` is the version
- `{"name":"tim"}` is the body
- everything else is the headers

HTTP Methods:
- `GET` get a resource
- `POST` create
- `PUT` update
- `DELETE` delete a resources
- `OPTIONS` create metadata about a resource

Headers:
- Authorization
- Accept
- Content-Type
... a lot more

Body: the body format is defined by the `Content-Type` header. A client specifies what it takes with the `accept` header.

Response
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 15
Content-Encoding: gzip

{"id":"12", "name":"tim"}
```
- `200 OK` is the status

Status codes
- `1xx` information
- `2xx` are the successful one
- `3xx` succeded but not getting what you asked for
- `4xx` bad request
- `5xx` server error

Content types: Mine types
- `text/html`
- `application/json`
- `image/jpg`
- `video/mp4`

> note that in things like `express`, `res.send(<thing>)` will return the thing as part of the output

### CURL
Making a request
`curl -v https://quote.cs260.click`
- `-v` is verbose
- `-X` lets you specify a http type like POST, PUT....
- `-H` lets you set the header
- `-d` is the data (remeber it depends on what kind of data you want to use)
- `-c` lets you specify a file to store cookies in
- `-b` is used to specifiy a file that has cookies in it that will be sent to service.

From the browser, we can only do `GET` requests.

`curl -X POST https://quote.cs260.click -d '{"author":"lee", "quote":"code fast"}'` is a valid request, but the endpoint doesn't actually allow you to do this.

Fetch is the `js` that will make a request `fetch(url).then(r => r.json()).then(j => console.log(j.value))`. First makes the request, converts to json and then prints it.

`fetch(quote.cs260.click).then((r) => r.json()).then(t => console.log(t))` 

## Cookies
Cookies are used to track data because HTTP requests don't have access to anything like that. They are generated by a server adn passed to the client as an HTTP header. It is basically an authentication token that you give to the user as long as they are logged in.

```
HTTP/2 200
Set-Cookie: myAppCookie=tasty; SameSite=Strict; Secure; HttpOnly
```

Every time the client makes a request, it returns the cookie to the server.

## URL
```
https://byu.edu:443/cs/260/student?filter=accepted#summary
<scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>
```
This is the general format.
- `scheme` is the protocol
- `domain name` is the domain
- `port` is the port used to connect to the domain's server. HTTP defaults to 80, HTTPS defaults to 443
- `path` the path to the resource. This is not necessarily an actual path, but can be a logical representation of a path
- `parameters` are the parameters or filters, sometimes called query string
- `anchor` a sub-location in the resource, called hash, or fragement id (this is where auto-scrolling happens)

> A URN (uniform resource name) does not specify location information
> A URI (uniform resource identifer) can refer to a URL or URN.

# Ports
Ports allow us to use different connection protocols (like HTTP, HTTPS, or SSH).

You can have as many servers as you want, but each need a different port.

![ports](./ports.png)

# Web Servers
A web server hosts a web service and also knows how to accept connections and speak with HTTP. It is separate from the service. In today's world, we have made it so you can have a web server that contains your service.

Express is a web server that can host your service.
```
const express = require('express');
const app = express();

// Serve static files from the 'public' directory
app.use(express.static('public'));

app.listen(80);
```
This program initalizes `express` and makes it so that you can serve static files.

## Endpoints
Endpoints are methods that we can call from the web. This makes it ineractive (rather than just giving a static HTML file). Add an endpoint like this
```
app.get('/time', (req, res) => {
  res.json({ time: new Date().toDateString() });
});
```
Note that `get` is the HTTP action, and `/time` is the path.

## Gateways
Gateways are web services that can serve up other services on different ports. We connect with a web server to our gateway and then it will connect us to the other services we have. So people connect to the gateway on port 443 and behind the scenes it redirects them to other ports.
![gateways.png](./gateways.png)

## Microservices
A single small web services that you can duplicate to handle more users

## Serverless
This came after microservices. This basically takes the server out of the whole process. Everything else is handled by the gateway.

# Web services
The frontend is the `index.html` and everything else that that references.

If we want our frontend to make a request to another service, we use `fetch(<url>)`. We want other people to be able to do the same for our service. Right now with React, JS, html, and css we have all the frontend, but we want to be able to make a web service that allows other people to call it. So we need to make the backend.

An `endpoint` or `API` is just a function that you call that belongs in another program. We access them with the `fetch` function.

![backend](./backend.png)

So basically, our service contains our static files (frontend containing html, js, css, react...), our endpoints that the frontend calls to change things, and other requests (API's) that call other services. Our frontend can also call other services as well.

# `Fetch`
`fetch` is built into the browser's js runtime. It takes a URL and returns a promise. You pass it a url, and then call `then` on the result. In then, we pass a fucntion that is called after the data is retrieved.
```
fetch('https://quote.cs260.click')
  .then((response) => response.json())
  .then((jsonResponse) => {
    console.log(jsonResponse);
  });
```
Returns
```
{
  author: 'Kyle Simpson',
  quote: "There's nothing more permanent than a temporary hack."
}
```

You can also `POST` things by passing in an HTTP request
```
fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  body: JSON.stringify({
    title: 'test title',
    body: 'test body',
    userId: 1,
  }),
  headers: {
    'Content-type': 'application/json; charset=UTF-8',
  },
})
  .then((response) => response.json())
  .then((jsonResponse) => {
    console.log(jsonResponse);
  });
```

# Now we are writing a backend service thing
We make a fetch request - by default is `index.html`. We write a super small program that listens and returns something. Everything up to the port gets to the right program. The program takes in the path and returns something (like a json file). We can return html, or static files.

# Service Design
How can we use good software design? The endpoints we are using will be called by other people.

Try to make endpoints human readable and discoverable. Try to make it so that your endpoints are backwards compatable. Make sure things are documented as well.

There are a few ways to organize endpoints in cluding REST, GraphQL, and RPC.

There is a lot more information about this that you can check out.

# Node Web Service
Create a node project.

```
const http = require('http');
const server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.write(`<h1>Hello Node.js! [${req.method}] ${req.url}</h1>`);
  res.end();
});

server.listen(8080, () => {
  console.log(`Web service listening on port 8080`);
});
```
This creates an HTTP server. Every time it receives a HTTP request, it calls the function. You can run this in the console by running `node index.js`, or you can run it in vscode which will enable the debugger.

# Express
We use npm to pull down express which makes this easier.

> "People tell you to not reinvent things, but I think you should ... it will teach you things" - TJ Holowaychuk

Express is just some js code that makes some wrappers over network requests. It executes things in order every time you get a new HTTP request!!!

Key objects:
- `express` constructor and default functionality. Top level object, when we call it it will create the app
- `app` is the service application, sets the port.
- `req` and `res` app gives you request and response. HTTP request and response.
```
const express = require('express');
const app = express();
app.listen(8080);
```

`express.static('public');` will look in the public folder for static files

```
const express = require('express');         // note that all objects are also functions in JS, this imports the code
const app = express();                      // that exports one object called express

// specify endpoint
// whenever we have a get request, we take anything (*, could also be a specific path)
app.get('*', (req, res) => {                // any get method will send Hello Express! right back
    res.send('<h1>Hello Express!</h1>');
});

app.listen(3000, () => {                    // what port we want to listen on with a function to call when it works
    console.log('Server is running on http://localhost:3000');
});
```

Run the program from vs code and open in your browser, then use a curl request `curl -v localhost:3000`. Express looks at what you return and determines if it is a string.

We could also do something like `res.send(404, '<h1>Not found</h1>');`. 

It is kinda weird that takes html files and stick it right in your code. So we can return a static file instead. `app.use(express.static('pubic'));`. `app.use` doesn't care if it is a get request or anything else. It will return whatever they asked for. So we can create files like `index.html`, `john.html`. Then when we request `localhost:3000/john.html` it will give you that. We can even serve up images or things like that by replacing the file with `image.png` or something like that.

You can include parameters from a url.
```
app.get('/store/:storeName', (req, res, next) => {
  res.send({ name: req.params.storeName });
});
```

# Responses
```
res.send('<p>html</p>');    // HTML
res.send('text');           // HTML
res.send({ x: '3', y: 4 }); // JSON
res.json({ x: '3', y: 4 }); // JSON
```

The order of your handlers is important. If you have a valid index.html that you register before a * handler, it will go get the index.html.

Put these in Get handlers
```
res.redirect(301, 'https://cs260.click')    // redirect if the page has moved

res.sendFile('index.html', {root: 'public' });  // basically the same thing as static files, but only for one

// these are the same
res.status(400).send('trouble in River City');  // status code.
res.send(400, 'trouble in River City');
```

# Middleware
This is a standard design method (like iterators). The Mediator (like Express) doesn't really know how to do things, but it calls other stuff to do different things (the middleware). The idea is we get some sort of request, then it goes to request, next and then request, then response and pass out the HTTP response.

We don't want Bob to steal our money. In our case it is more like an authToken or something like that.
```
function noBobs(req, res, next) {       // if a certain case (/bob path), it will return something and if not, it will default to next function.
    /bob/.text(req.path) ? res.status(401).send('No Bobs!') : next();
}

app.get('/secrets', noBobs, (req, res) => {     // if noBobs succeeds, it will call the next function (req, res)
    res.send('<p>Hello</p>');                   // note that the next function is in the noBobs.
});
```
This is useful for authentication. Make it a secure enpoint basically.

![middleware](./middleware.png)

We could even change the request
```
function noBobs(req, res, next) {       // if a certain case (/bob path), it will return something and if not, it will default to next function.
    res.isBob = /bob/.test(req.path);
    next();
}

app.get('/secrets/*', noBobs, (req, res) => {    // if noBobs succeeds, it will call the next function (req, res)
    res.send(\`<p> hello bob? ${req.isBob ? "yes" : "no"}\`);
});
```

Parameters
```
// 
app.get('/store/:id/:time', (req, res) => {
    res.send({ id: req.params.id, time: req.params.time });
});

app.put('/*/:id', (req, res) => {
    res.send({ update: req.params.id });
});

app.dlete(/\/store\/(.*)/, (req, res) => {
    res.send({ delete: req.params[0] });
});
```

Parsing json files
```
app.use(express.json());    // parsing json requests

app.put('/data', (req, res) => {
    res.send(req.body.msg);
});
```

> note that `res.send({body})` will send back the result with the specified body.

## Built in middlware
```
app.use(express.static('public'));
```
Will respond with static files that match the URL

`npm install cookie-parser`
```
const cookieParser = require('cookie-parser');

app.use(cookieParser());

app.post('/cookie/:name/:value', (req, res, next) => {
  res.cookie(req.params.name, req.params.value);
  res.send({ cookie: `${req.params.name}:${req.params.value}` });
});

app.get('/cookie', (req, res, next) => {
  res.send({ cookie: req.cookies });
});
```
This is an example of a third party middleware function. We often see middleware adding fields to `req` and `res`.

## You rown middleware
```
app.use((req, res, next) => {
  console.log(req.originalUrl);
  next();
});
```
This is a logging function.
## Error handling middleware
```
app.get('/error', (req, res, next) => {
  throw new Error('Trouble in river city');
});

app.use(function (err, req, res, next) {
  res.status(500).send({ type: err.name, message: err.message });
});
```
This throws an error and then immediately catches it and returns the result.

# Modules
## Node modules (CommonJS modules)
Need to export and import them. `const express = require('express');`

If you want to export your own
```
function alertDisplay(msg) {
    alert(msg);
}

module.exports = {
    alertDisplay,
};
```

## JS modules (ES modules) with Node
If you want to use JS modules with Node, you need to specify that in `package.json`
```
{
  "name": "service",
  "version": "1.0.0",
  "description": "This demonstrates a service for a web application.",
  "type": "module",
  "dependencies": {             // this is the place
    "express": "^4.18.2"
  }
}
```

To use them, do
```
import express from 'express`;
express().listen(3000);
```

To export from your own code:
```
export function alertDisplay(msg) {
  console.log(msg);
}
```
Then import it in another file
```
import { alertDisplay } from './alert.js';

alertDisplay('called from main.js');
```

## JS modules (ES modules) in a browser
Modules can only be called from other modules. 
```
<script type="module">
  import { alertDisplay } from './alert.js';
  alertDisplay('module loaded');
</script>
```

If we wnat to use a module in a global scope:
```
<html>
  <body>
    <script type="module">
      import { alertDisplay } from './alert.js';
      window.btnClick = alertDisplay;

      document.body.addEventListener('keypress', function (event) {
        alertDisplay('Key pressed');
      });
    </script>
    <button onclick="btnClick('button clicked')">Press me</button>
  </body>
</html>
```

# Security
SOP or Same Origin Policy is that JS can only make requests to a domain if it is in the same domain the user is viewing. This doesn't work great if you want to use a public resource.

CORS or Cross Origin Resource Sharing is where the client talks to the server and gives it the origin of a request. Based on that the server responds with what is allowed. 

The browser is in charge of doing this.

Make sure to test services before using them. When you make a request, the response will include if you are allowed to access it with the header `access-control-allow-origin`.

# Authentication vs Authorization
- Authentication: username and pasword
- Authorizatoin: Access to different thigns

Pass an auth token back to our service, the backend looks at it and checks to make sure everything is good. Then it saves teh score.

Standard protocols for Authentication:
- OAuth
- SAML (really old)
- CAS (The one BYU uses)
- OIDC (adds Authorization onto OAuth)

Single sign on: use same credentials for multiple web apps. Federated login: login once and authToken used for multiple websites, like logging into gmail, youtube, google docs.
- AuthO
- Google
- Facebook
- Duo
- AWS

It is really easy to mess up authentication.

We create our own Custom authentication. We need to 
- store user credentials
- verify credentials
- restrict access

## Account creation and login
Need three endpoints (four is helpful)
- register (POST)
- login (POST)
- logout (DLETE)
- get me (GET)

### Requests
An example of register would look like:
```
POST /api/auth HTTP/2
Content-Type: application/json
{
  "email":"marta@id.com",
  "password":"toomanysecrets"
}

HTTP/2 200 OK
Content-Type: application/json
Set-Cookie: auth=tokenHere
{
  "email":"marta@id.com"
}
```

### Service
The code for this would look something like this
```
const express = require('express');
const app = express();

//register
app.post('/api/auth', async (req, res) => {
  res.send({email: 'marta@id.com'});
});

// login
app.put('/api/auth', async (req, res) => {
  res.send({ email: 'marta@id.com' });
});

// logout
app.delete('/api/auth', async (req, res) => {
  res.send({});
});

// getMe
app.get('/api/user', async (req, res) => {
  res.send({ email: 'marta@id.com' });
});

app.listen(3000);
```

### Handle requests
We know everything we receive will be a json object. So we want to parse everything that way.
```
app.use(express.json());

app.post('/api/auth'< (req, res) => {
  res.send(req.body);
});
```
This will parse everything as json.

#### Users and passwords
How do we store credentials successfully? We don't want to just store a raw text password. If they get in you db, they have access to all your passwords. So we cryptographically hash it. We cannot get to it again, but what we can do is we can get a password and hash it and then look if they match.
- `Salt` puts random generated text onto your password and then it 
- `Pepper` is a random value you put on all of the passwords, but you don't share it.

We will use `Bcrypt`. In `webServices/login/exampleCode/bcrypt`. Step through this for help.


Use this code:
```
const bcrypt = require('bcryptjs');

const users = [];

async function createUser(email, password) {
  const passwordHash = await bcrypt.hash(password, 10);

  const user = {
    email: email,
    password: passwordHash,
  };

  users.push(user);

  return user;
}

function getUser(field, value) {
  if (value) {
    return users.find((user) => user[field] === value);
  }
  return null;
}
```

### Register
If we have the user already, return a 409 error. If we don't, it will create a user and then return the users email. We need to generate an auth token and store it on the browser with a cookie.
```
app.post('/api/auth', async (req, res) => {
  if (await getUser('email', req.body.email)) {
    res.status(409).send({ msg: 'Existing user' });
  } else {
    const user = await createUser(req.body.email, req.body.password);
    res.send({ email: user.email });
  }
});
```

#### Authorization tokens
`npm install uuid` This is an authtoken. We don't want the authToken to be tied to the password. It uses an algorithm, it is extremely unlikely that it will return the same thing twice.
```
const uuid = require('uuid');
const token = uuid.v4()
...
```

#### How do we pass the UUID (Auth tokens) around? Cookies
The service generates an authToken. It stores it and sends it back in a cookie  The frontentd only cares that you have thie token. Cookies are a way where the frontend recovnizes if you have been there before. The server will ask for it every time until it takes it away. The frontend can't read the cookie, it just recovnizes that it has been there

When we set the cookie, we include a few options.
```
Set-Cookie: token=<uuid>; Secure; HttpOnly; SameSite=Strict

```
- `Secure` will only do HTTPS and not HTTP
- `HttpOnly` will say that JS can't read the cookie
- `SameSite=Strict` only give the cookie to the backend that generated the cookie.

So things will look somethin glike this
```
const cookieParser = require('cookie-parser');
app.use(cookieParser());

// Create a token for the user and send a cookie containing the token
function setAuthCookie(res, user) {
  user.token = uuid.v4();

  res.cookie('token', user.token, {
    secure: true,
    httpOnly: true,
    sameSite: 'strict',
  });
}
```

#### How to store the auth token in the cookie
Should look like something like this
```
const cookieParser = require('cookie-parser');
const uuid = require('uuid');

app.use(cookieParser());

function setAuthCookie(res, user) {
  user.token = uuid.v4();

  res.cookie('token', user.token, {
    secure: true,
    httpOnly: true,
    sameSite: 'strict',
  });
}

// Registration endpoint
app.post('/api/auth', async (req, res) => {
  if (await getUser('email', req.body.email)) {
    res.status(409).send({ msg: 'Existing user' });
  } else {
    const user = await createUser(req.body.email, req.body.password);

    setAuthCookie(res, user);

    res.send({ email: user.email });
  }
});
```

### login
```
app.put('/api/auth', async (req, res) => {
  const user = await getUser('email', req.body.email);
  if (user && (await bcrypt.compare(req.body.password, user.password))) {
    setAuthCookie(res, user);

    res.send({ email: user.email });
  } else {
    res.status(401).send({ msg: 'Unauthorized' });
  }
});
```
`bcrypt.compare` taqkes in the text password and does its hash thing and compares it to the stored user password.

If the user exists and the passwords match, then we make a cookie and return the email, if not we return a 401 code.

### logout
```
app.delete('/api/auth', async (req, res) => {
  const token = req.cookies['token'];
  const user = await getUser('token', token);
  if (user) {
    clearAuthCookie(res, user);
  }

  res.send({});
});

function clearAuthCookie(res, user) {
  delete user.token;
  res.clearCookie('token');
}
```
If there is an actual user, we delete the token and cookie. If not, we ignore it.

### getMe
```
app.get('/api/user/me', async (req, res) => {
  const token = req.cookies['token'];
  const user = await getUser('token', token);
  if (user) {
    res.send({ email: user.email });
  } else {
    res.status(401).send({ msg: 'Unauthorized' });
  }
});
```
This will make sure we have a saved token sent back from the client. We check it and return the email if it is valid.

> We use curl as our client `curl localhost:3000/register -H "Content-Type: application/json" -d '{"user":"cow","password":"1"}'` will retister a user.
> We are using the `express.json()` middleware, so we include `application/json` which will parse it as a json.
> We use curl as our client `curl -X PUT localhost:3000/register -H "Content-Type: application/json" -d '{"user":"cow","password":"1"}'` will retister a user.

## Summary
So basically we make a register request and the service will add a new user with new cookie info. It will send back the cookie data to the client and print out the user email.
Then when we login, curl handles the cookie (because we )

## Connecting it all together
Create an npm project with `npm install vite@latest -D`, `npm install react react-dom react-router-dom`. 
`index.jsx`
```
function App() {
  return (
    <BrowserRouter>
      <main>
        <Routes>
          <Route path='/' element={<Login />} exact />
          <Route path='/profile' element={<Profile />} />
        </Routes>
      </main>
    </BrowserRouter>
  );
}
```
Basic browser router login component

`Login`
```
function Login() {
  const navigate = useNavigate();
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');

  function handleLogin() {
    createAuth('PUT');
  }

  function handleRegister() {
    createAuth('POST');
  }

  async function createAuth(method) {
    const res = await fetch('api/auth', {
      method: method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });
    await res.json();
    if (res.ok) {
      navigate('/profile');
    } else {
      alert('Authentication failed');
    }
  }

  return (
    <div>
      <h1>Login</h1>
      <div>
        <label>Email:</label>
        <input type='text' onChange={(e) => setEmail(e.target.value)} required />
      </div>
      <div>
        <label>Password:</label>
        <input type='password' onChange={(e) => setPassword(e.target.value)} required />
      </div>
      <button type='submit' disabled={!(email && password)} onClick={handleLogin}>
        Login
      </button>
      <button type='button' disabled={!(email && password)} onClick={handleRegister}>
        Register
      </button>
    </div>
  );
}
```
So we are always updating the email and password. Then when the user clicks one of th ebuttons (handle login or handle register), we call that function and then it creats an authorization with a specific HTML method. It sends the correct data over and may navigate, but may not.

`Profile`
```
function Profile() {
  const navigate = useNavigate();
  const [userInfo, setUserInfo] = React.useState('');

  React.useEffect(() => {
    (async () => {
      const res = await fetch('api/user/me');
      const data = await res.json();
      setUserInfo(data);
    })();
  }, []);

  function handleLogout() {
    fetch('api/auth', {
      method: 'DELETE',
    });
    navigate('/');
  }

  return (
    <div>
      <h1>Profile</h1>
      <div>Logged in as: {userInfo.email}</div>
      <button type='button' onClick={handleLogout}>
        Logout
      </button>
    </div>
  );
}
```
On first render, it fetches the user info and converts it to json, then sets it. It has a logout button that will delete our authorization and return to the main page.

### Running
To run everything, f5 run index.js for the backend, and run the frontend with `npm run dev` in the root. All this is in `profile/webServices/login/exampleCode/login`.






## Going over the code
The frontend code is in the root, the backend is in a subdirectory.

Anything security related should be done in the backend.

What endpoints do we want? 
- `post`, `/api/auth` Creates an authentication token (register)
- `put`, `/api/auth` Update authorization (login)
- `delete`, `/api/auth` logout (delete authentication token)
- `get`, `/api/user/me` get the current user information for the currently authenticated user.

The browser automatically returns the cookie as soon as the backend sets it.

Have to start both the frontend and the backend.

# Deployment
For us we build something, and then push it to github. Then every once in a while we `deploy.sh` it to production. Normally people just start with React.

In industry things are a little different. It starts with the developer. They push to a version repository where it goes through testing and analysis in a continuous integration (CI) program. If it passes there, it goes to a version repository. That contains all the versions. Then that controls pushing it to production. Sometimes we have a staging environment which doesn't have user data. This is only used internally. All the teams look at it internally first and they work on it. A Sales environment has dummy data. You can also have other environments like integration testing, or penetration or load testing.

A peculiarity of this class. Everything outside of service is frontend code. Inside service is backend code. Vite looks in src to compile everything together.
Now that we write a service, we are in charge of hosting the static files. We want to use vite's hot loading server that continuously updates. Right now we have two servers one for the frontend and the other for the backend. We want to switch that so we can update them all at the same time. So the backend code starts as a subdirectory of the frontend code and then it flips.

# Shell Script
Not there are two different programs with different dependencies, the frontend and the backend. Both you have to `npm install`

# Uploading files
`npm install express multer`
- `express` handles network communicaiton
- `multer` handles HTTP file transfer

With files, the data is huge and `multer` handles all the details for you

`mkdir fileDemo && cd fileDemo`
`npm init -y`
`npm install express multer`
open vs code
the package.json file has the correct depencencies
create index.js

```
const upload = multer({
    storage: multer.discStorage({
        destination: 'public/',     // write things to public direcctory
        filename: (req, file, cb) => {      // renames the file
            const filetype = fil.originalname.split('.').pop();
            const id = Math.round(Math.random() * 1e9);
            const filename = `${id}.${filetype}`;
            cb(null, filename);
        },
    }),
    limits: { fileSize: 64000 },    // sets a storage capacity
});

// post request. When we have an upload request, it calls the multer middleware, and then calls our function.
// our static middleware is going to 


```

Express gets requests and it walks down the tree to find a mathing function. 

Our frontend
```
```

Express will be our HTTP server. We need to create a public directory, create an `index.html` then add a the frontend .js file.

Fetch by default returns a promise....

Launch backend code in vscode and debug the frontend code in the browser. We rented 8gb.

AWS S3 has a big capacity, only pay for what you use. You can call their services to store more things.

# Databases
Our service makes a request to get the scores. Our service doesn't store those, so we talk to a database even farther back. Our database is not on our server because of storage space.

Relational databases and relational queries. SQL is basically the standard for retrieving data.

The nice thing is that we are using someone else to store our data. So we don't have to install any crazy software.

| Service | Specialty | 
| --- | --- |
| MySQL | Relational queries |
| Redis | Memory cached objects: didn't store on disk, they just stored in memory. Super fast |
| ElasticSearch | Ranked free text: store a whole book, search through it |
| MongoDB | JSON objects: make it easy for programmers |
| DynamoDB | key value pairs: key and a value |
| Neo4J | Graph based data: like a network |
| InfluxDB | Time series data |

## MongoDB
Collections of data, products, users, purchases is called a database. Clusters are copies of databases for redundancy.

Collection, three different documents {} in collection []. It will automatically specify the id if you don't.

Mongo is pretty fluid (like js) of what you can add to objects.

Cluster -> Database -> collections (useres, scores, classes taken)



mongo VYDxe1N1o1i2yqmy

git init
npm init things
npm install mongodb

```
mongodb+srv://mongo:<db_password>@morsecodeclicker.jxrmo.mongodb.net/?retryWrites=true&w=majority&appName=morsecodeclicker
```
- `mongodb+srv` is a custom protocol for efficiency
- `mongo:<db_password>` is the username and password for our database. This is generally bad, but they have their own protocola that is encrypted so it is fine.
- `@morsecodeclicker` is the hostname
- `jxrmo.mongodb.net` is their hostname
- `?` after this is parameters.

```
const { MongoClient } = require('mongodb');   // import source code
const config = require('./dbConfig.json');    // bring in the credentials

const url= `mongodb+srv://${config.userName}:${config.password}@{config.hostname}`;   // the right url to talk to

const client = new MongoClient(url);    // initalize a MongoClient
const db = client.db('rental');         // using a database called rental (automatically created)
const collection = db.collection('house');    // using a collection called house (automatically created)
```

### Test the connection
```
try {
  await db.command({ping: 1});
  console.log(`DB connected to ${config.hostname}`);
} catch (ex) {
  console.log(`Error with ${url} because ${ex.message}`);
  process.exit(1);
}
```
> Note that in order to do this, we need to put our `await` in an `async` function.

```
async function main() {
  try {
    await db.command({ping: 1});
    console.log(`DB connected to ${config.hostname}`);
  } catch (ex) {
    console.log(`Error with ${url} because ${ex.message}`);
    process.exit(1);
  }
}

main().then(() => {
  console.log("DONE!");
  }
);
```

Inserting `await collection.insertOne(house);`

> You need to close the network connection at the end with `await client.close();`. Do this with at `try finally` block.

### Querying data
`collection.find();` return everything
`collection.find({beds: { $gte: 2}});` any object that has a `beds` field that is greater than or equal to 2
`colleciton.find({status: 'open', beds: {$ls: 3} });`
`collection.find({$or: [{beds: {$lt: 3}}, {price: {$lt: 1000}}]});`

You can also include how you want the data to return

```
const options = {
  sort: {name: -1},
  limit: 10,
};

const cursor = collection.find(query, options);
const rentals = await cursor.toArray();
rentals.forEach((i) => console.log(i));
```

### Deleting data
```
const query = { property_type: 'Condo', beds: {$lt:2}};
await collection.deleteMany(query);


```

### Update functionality


# Simon/Startup DB
Clone it.
Probably won't have any changes in frontend code.
Remember to use `npm install` in the service directory. That will install make a folder `node_modules`
There are two programs a service and a client or a backend and a frontend. The backend runs in virginia. The frontend runs on the browser. Our repo has the frontend and backend code. The frontend code is in the root, the backend is in the service directory.

Line 1: require mongo

Note on the `require` syntax. This is a nodejs thing, but then JS came up with their own thing esmodules (`import`) that are becomming more common. We use commonjs and our backend uses esmodules.
Import: `const { MongoClient } = require('mongodb');`
Export: 
```export function alertDisplay(msg) {
  console.log(msg);
}
```

Line 2: dbConfig.json file
Line 4: accesses `dbConfig.json` and gets our url for the database
Line 5: specify the client
Line 6: create a database
Line 8: create a collection for scores

Line 11: connects to the database to make sure it is working. Note that it is an async function that doesn't work in the top level, so we create it and then call it immediately. So it will go to other code adn asyncrousnly do it. If it fails, it will crash the program.

Line 21: a function to find and get the user by email
Line 25: a function to find and get the user by token
Line 29: a funciton to insert a new user
Line 33: a function to update a user
Line 37: a function to insert a new score
Line 41: a function to get the high scores (we let mongo do all the work)

`index.js`
Line 11: parse command line arguments
Line 14: if it is json, parse it
Line 17: cookie parser
Line 20: load up static files
It pulls out all the memory stuff and puts in database stuff.

To debug our code, we need to run two programs. We got to index.js and do f5, debug with Node.js This is the backend running under express in the service directory. Then we have our frontend code using react. We use `npm run dev` which executes `vite` or even `curl`. But we need to install `vite` with `npm install`. Now we run it again. 

Our frontend will be run by vite on port 5173. But we want it to proxy all the requests to the backend so we need to set up a `vite.config.js` file with these parameters in the root of the project.
```
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    proxy: {
      '/api': 'http://localhost:3000',
    },
  },
});
```
The whole process will look something like this.
![development process](development.png)

> When running in production, the Simon web service running under Node.js on port 3000 serves up the bundled Simon React application code when the browser requests index.html. The service pulls those files from the application's static HTML, CSS, and JavaScript files located in the public directory as described above.
> 
>However, when the application is running in debug mode in your development environment, we actually need two HTTP servers running: one for the Node.js backend HTTP server, and one for the Vite frontend HTTP server. This allows us to develop and debug both our backend and our frontend while viewing the results in the browser.
>
> These programs talk over the network over each other. They don't need to be physcially connected to do it.

So there are two servers we are using for development, and only one for production.

Have the database do as much as possible (if it is a relationsal database)

Two server system for development
One server system for deployment
Rearranging folders and stuff


The vite configuration file will forward every request that ends in `/api` will forward it to 'http://localhost:3000' which is only for development. In production, the static files are loaded up by the backend server. The static files then make requests back to the backend that loaded it up. See simon deployment stuff for the service for extra info.

Remember then syntax with promises.
```
React.useEffect(() => {
    setImageURL('url(/background3.png)');

    fetch('/api/auth/user').then((res) => {
      res.json();
    }).then((user) => {
      changeEmail(user);
    });
}, []);
```
In this example,we use `{}` on our first then statement and so we don't automatically return anything. In every promise, using the `then` syntax, the result of the promise is passed in as a parameter to the next then statement. So in our case, user will be undefined bcause we don't return anything. To fix it, we just need to add a `return`.
```
React.useEffect(() => {
    setImageURL('url(/background3.png)');

    fetch('/api/auth/user').then((res) => {
      return res.json();
    }).then((user) => {
      changeEmail(user);
    });
}, []);
```

Also with the whole store the current user thing. That is a bad idea because our database needs to store global data and not local data.