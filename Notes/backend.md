# Making Service Requests with HTTP or CURL
The browser inplicitly asks for `index.html`. Then it gets the file from the server. The server returns those static files. What if the JS running in the front end could make their own requests? So they introduced the XML API. It can go and return the weather or just about anything you want. If we want to request something else, we communicate with HTTP requests.

We make service requests with `curl` looks like:
```
curl -v -s http://info.cern.ch/hypertext/WWW/Helping.html
```

We can change our server to call up service endpoints. These are just functions/methods. Sometimes they are called API's. My service can also call other services like a database or other API. When we hard reload a page, it makes a bunch of service requests (HTML requests for different resources).`xhr` are service requests.

How do we get a resource: `https://byu.edu:443/api/city?q=pro#3`
- `https://` is the scheme or what language we are speaking in
- `byu.edu` is the domain name or who we want to talk to
- `:443` is the port or what software we want to talk to, kind of like the address.
- `/api/city` is the path
- `?q=pro` is the parameter (separated with `&`)
- `#3` is the anchor (one of the sections (often an id on an html tag))

Our server has two programs that are running. One is simon, the other is startup. Both are running on different ports.

It would be confusing if you sayd go to port 3000 on my server. So instead by default go to port 443 (port 80 is the insecure one) with a specific domain name (like `simon.` or `startup.`). So we have Caddy listening on 443. Caddy has a table for the `simon.` or `startup.`. It will then forward it to one program or the other and then return it at the end. Caddy is called a proxy. The programs it runs are differentiated by the subdomain name.

There is another program called SSHD which is how we run the deployment scripts. It is on port 22.

When we go to a website while our port is running, it will connect over port 443, but then slide us over to another port.

## HTTP Requests
Server doesn't make requests to the client. The client makes requests to the server. Here is an example request.
```
POST /user HTTP/1.1
Host: cs260.click
User-Agent: curl/7.77.0
Content-Length: 14
Accept: application/json, text/plain, */*
accept-encoding: gzip, deflate

{"name":"tim"}
```

The basic syntax looks like this:
```
<verb> <url path, parameters, anchor> <version>
[<header key: value>]*
[

  <body>
]
```

- `POST` is the method
- `/user` is the path
- `HTTP/1.1` is the version
- `{"name":"tim"}` is the body
- everything else is the headers

HTTP Methods:
- `GET` get a resource
- `POST` create
- `PUT` update
- `DELETE` delete a resources
- `OPTIONS` create metadata about a resource

Headers:
- Authorization
- Accept
- Content-Type
... a lot more

Body: the body format is defined by the `Content-Type` header. A client specifies what it takes with the `accept` header.

Response
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 15
Content-Encoding: gzip

{"id":"12", "name":"tim"}
```
- `200 OK` is the status

Status codes
- `1xx` information
- `2xx` are the successful one
- `3xx` succeded but not getting what you asked for
- `4xx` bad request
- `5xx` server error

Content types: Mine types
- `text/html`
- `application/json`
- `image/jpg`
- `video/mp4`

Making a request
`curl -v https://quote.cs260.click`

From the browser, we can only do `GET` requests.

`curl -X POST https://quote.cs260.click -d '{"author":"lee", "quote":"code fast"}'` is a valid request, but the endpoint doesn't actually allow you to do this.

Fetch is the `js` that will make a request `fetch(url).then(r => r.json()).then(j => console.log(j.value))`. First makes the request, converts to json and then prints it.

`fetch(quote.cs260.click).then((r) => r.json()).then(t => console.log(t))` 

## Cookies
Cookies are used to track data because HTTP requests don't have access to anything like that. They are generated by a server adn passed to the client as an HTTP header.

```
HTTP/2 200
Set-Cookie: myAppCookie=tasty; SameSite=Strict; Secure; HttpOnly
```

Every time the client makes a request, it returns the cookie to the server.

## URL
```
https://byu.edu:443/cs/260/student?filter=accepted#summary
<scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>
```
This is the general format.
- `scheme` is the protocol
- `domain name` is the domain
- `port` is the port used to connect to the domain's server. HTTP defaults to 80, HTTPS defaults to 443
- `path` the path to the resource. This is not necessarily an actual path, but can be a logical representation of a path
- `parameters` are the parameters or filters, sometimes called query string
- `anchor` a sub-location in the resource, called hash, or fragement id (this is where auto-scrolling happens)

> A URN (uniform resource name) does not specify location information
> A URI (uniform resource identifer) can refer to a URL or URN.

# Now we are writing a backend service thing
We make a fetch request - by default is `index.html`. We write a super small program that listens and returns something. Everything up to the port gets to the right program. The program takes in the path and returns something (like a json file). We can return html, or static files.

# Service Design
How can we use good software design? The endpoints we are using will be called by other people.

# Express
We use npm to pull down express which makes this easier.

> "People tell you to not reinvent things, but I think you should ... it will teach you things" - TJ Holowaychuk

Express is just some js code that makes some wrappers over network requests. 

`express.static('public');` will look in the public folder for static files

5 objects:
- `express` constructor and default functionality. Top level object, when we call it it will create the app
- `app` is the service application, sets the port.
- `req` and `res` app gives you request and response. HTTP request and response.

`mkdir tj`
`npm init -y`
`npm install express`


```
const express = require('express');         // note that all objects are also functions in JS, this imports the code
const app = express();                      // that exports one object called express

// specify endpoint
// whenever we have a get request, we take anything (*, could also be a specific path)
app.get('*', (req, res) => {                // any get method will send Hello Express! right back
    res.send('<h1>Hello Express!</h1>');
});

app.listen(3000, () => {                    // what port we want to listen on with a function to call when it works
    console.log('Server is running on http://localhost:3000');
});
```

run from the console `node index.js`. Then we go to localhost with the port.

If the port is already in use, it will say so. 

Run the program from vs code, then use a curl request `curl -v localhost:3000`. Express looks at what you return and determines if it is a string.

We could also do something like `res.send(404, '<h1>Not found</h1>');`. 

It is kinda weird that takes html files and stick it right in your code. So we can return a static file instead. `app.use(express.static('pubic'));`. `app.use` doesn't care if it is a get request or anything else. It will return whatever they asked for. So we can create files like `index.html`, `john.html`. Then when we request `localhost:3000/john.html` it will give you that. We can even serve up images or things like that by replacing the file with `image.png` or something like that.

# Responses
```
res.send('<p>html</p>');    // HTML
res.send('text');           // HTML
res.send({ x: '3', y: 4 }); // JSON
res.json({ x: '3', y: 4 }); // JSON
```

The order of your handlers is important. If you have a valid index.html that you register before a * handler, it will go get the index.html.

Put these in Get handlers
```
res.redirect(301, 'https://cs260.click')    // redirect if the page has moved

res.sendFile('index.html', {root: 'public' });  // basically the same thing as static files, but only for one

// these are the same
res.status(400).send('trouble in River City');  // status code.
res.send(400, 'trouble in River City');
```

# Middleware
This is a standard design method (like iterators). It doesn't really know how to do things, but it calls other stuff to do different things. The idea is we get some sort of request, then it goes to request, next and then request, then response and pass out the HTTP response.

We don't want Bob to steal our money. In our case it is more like an authToken or something like that.
```
function noBobs(req, res, next) {       // if a certain case (/bob path), it will return something and if not, it will default to next function.
    /bob/.text(req.path) ? res.status(401).send('No Bobs!') : next();
}

app.get('/secrets', noBobs, (req, res) => {    // if noBobs succeeds, it will call the next function (req, res)
    res.send('<p>Hello</p>');
});
```
This is useful for authentication. Make it a secure enpoint basically.

We could even change the request
```
function noBobs(req, res, next) {       // if a certain case (/bob path), it will return something and if not, it will default to next function.
    res.isBob = /bob/.test(req.path);
    next();
}

app.get('/secrets/*', noBobs, (req, res) => {    // if noBobs succeeds, it will call the next function (req, res)
    res.send(\`<p> hello bob? ${req.isBob ? "yes" : "no"}\`);
});
```

Parameters
```
// 
app.get('/store/:id/:time', (req, res) => {
    res.send({ id: req.params.id, time: req.params.time });
});

app.put('/*/:id', (req, res) => {
    res.send({ update: req.params.id });
});

app.dlete(/\/store\/(.*)/, (req, res) => {
    res.send({ delete: req.params[0] });
});
```

Parsing json files
```
app.use(express.json());    // parsing json requests

app.put('/data', (req, res) => {
    res.send(req.body.msg);
});
```

# Authentication vs Authorization
- Authentication: third party confirms who you are
- Authorizatoin: What can you do?

Pass an auth token back to our service, the backend looks at it and checks to make sure everything is good. Then it saves teh score.

Standard protocols for Authentication:
- OAuth
- SAML (really old)
- CAS (The one BYU uses)
- OIDC (adds Authorization onto OAuth)

Single sign on: use our credientials to log in
- AuthO
- Google
- Facebook
- Duo
- AWS

It is really easy to mess up authentication.

We create our own Custom authentication. We need to 
- store user credentials
- verify credentials
- restrict access

How do we store credentials successfully? We don't want to just store a raw text password. If they get in you db, they have access to all your passwords. So we cryptographically hash it. We cannot get to it again, but what we can do is we can get a password and hash it and then look if they match.
- `Salt` puts random generated text onto your password and then it 
- `Pepper` is a random value you put on all of the passwords, but you don't share it.

We will use `Bcrypt`. In `webServices/login/exampleCode/bcrypt`. Step through this for help.

## Example:
app.post is a post request with a `register` path.
app.put is updating the authorizaton

Then we run and debug the code.
 
We need to include a body.

We use curl as our client `curl localhost:3000/register -H "Content-Type: application/json" -d '{"user":"cow","password":"1"}'` will retister a user.
We are using the `express.json()` middleware, so we include `application/json` which will parse it as a json.
We use curl as our client `curl -X PUT localhost:3000/register -H "Content-Type: application/json" -d '{"user":"cow","password":"1"}'` will retister a user.

## Authorization tokens
`npm install uuid` This is an authtoken. We don't want the authToken to be tied to the password. It uses an algorithm, it is extremely unlikely that it will return the same thing twice.
```
const uuid = require('uuid');
const token = uuid.v4()
...
```


## How do we pass the UUID around? Cookies
The frontentd only cares that you have thie token. Cookies are a way where the frontend recovnizes if you have been there before. The server will ask for it every time until it takes it away.

We do a post with username and password, then we generate a token and store it. Then we stick the token into a cookie (which the frontend that can't read), but the next time we call the frontend, it returns the cookie to us.s


```
Set-Cookie: token=<uuid>; Secure; HttpOnly; SameSite=Strict

```
- `Secure` will only do HTTPS
- `HttpOnly` will say that JS can't read the cookie
- `SameSite=Strict` only give the cookie to the backend that generated the cookie.

## Example
`npm install express cookie-parser uuid`

```
//sample code
```

## Going over the code
The frontend code is in the root, the backend is in a subdirectory.

Anything security related should be done in the backend.

What endpoints do we want? 
- `post`, `/apa/auth` Creates an authentication token (register)
- `put`, `/api/auth` Update authorization (login)
- `delete`, `/api/auth` logout (delete authentication token)
- `get`, `/api/user/me` get the current user information for the currently authenticated user.

The browser automatically returns the cookie as soon as the backend sets it.

Have to start both the frontend and the backend.

# Deployment
For us we build something, and then push it to github. Then every once in a while we `deploy.sh` it to production. Normally people just start with React.

In industry things are a little different. It starts with the developer. They push to a version repository where it goes through testing and analysis in a continuous integration (CI) program. If it passes there, it goes to a version repository. That contains all the versions. Then that controls pushing it to production. Sometimes we have a staging environment which doesn't have user data. This is only used internally. All the teams look at it internally first and they work on it. A Sales environment has dummy data. You can also have other environments like integration testing, or penetration or load testing.

A peculiarity of this class. Everything outside of service is frontend code. Inside service is backend code. Vite looks in src to compile everything together.
Now that we write a service, we are in charge of hosting the static files. We want to use vite's hot loading server that continuously updates. Right now we have two servers one for the frontend and the other for the backend. We want to switch that so we can update them all at the same time. So the backend code starts as a subdirectory of the frontend code and then it flips.

# Shell Script
Not there are two different programs with different dependencies, the frontend and the backend. Both you have to `npm install`

# Uploading files
`npm install express multer`
- `express` handles netwrok communicaiton
- `multer` handles HTTP file transfer

With files, the data is huge and `multer` handles all the details for you

`mkdir fileDemo && cd fileDemo`
`npm init -y`
`npm install express multer`
open vs code
the package.json file has the correct depencencies
create index.js

```
const upload = multer({
    storage: multer.discStorage({
        destination: 'public/',     // write things to public direcctory
        filename: (req, file, cb) => {      // renames the file
            const filetype = fil.originalname.split('.').pop();
            const id = Math.round(Math.random() * 1e9);
            const filename = `${id}.${filetype}`;
            cb(null, filename);
        },
    }),
    limits: { fileSize: 64000 },    // sets a storage capacity
});

// post request. When we have an upload request, it calls the multer middleware, and then calls our function.
// our static middleware is going to 


```

Express gets requests and it walks down the tree to find a mathing function. 

Our frontend
```
```

Express will be our HTTP server. We need to create a public directory, create an `index.html` then add a the frontend .js file.

Fetch by default returns a promise....

Run the server using f5

Launch backend code in vscode and debug the frontend code in the browser. We rented 8gb.

AWS S3 has a big capacity, only pay for what you use. You can call their services to store more things.